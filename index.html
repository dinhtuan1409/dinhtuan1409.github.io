<script>
    const BOARD_SIZE = 300; // K√≠ch th∆∞·ªõc khung (px)
    const ROWS = 3;
    const COLS = 3;
    const PIECE_SIZE = BOARD_SIZE / ROWS; // 100px
    const TARGET_URL = 'ani2nam.html'; // T√™n file website 2 nƒÉm c·ªßa b·∫°n

    const puzzleBoard = document.getElementById('puzzle-board');
    const checkBtn = document.getElementById('check-btn');
    const messageEl = document.getElementById('message');
    const IMAGE_SRC = 'img/38.jpg'; // D√πng ·∫£nh n·ªÅn t·ª´ trang k·ª∑ ni·ªám c≈© l√†m ·∫£nh gi·∫£i ƒë·ªë

    let pieces = [];
    let isGameComplete = false;
    let dragElement = null;

    // 1. KH·ªûI T·∫†O M·∫¢NH GH√âP
    function createPieces() {
        puzzleBoard.innerHTML = ''; // X√≥a m·∫£nh gh√©p c≈©
        pieces = [];

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const index = r * COLS + c;

                const piece = document.createElement('div');
                piece.classList.add('puzzle-piece');
                piece.dataset.correctRow = r;
                piece.dataset.correctCol = c;
                piece.dataset.index = index;

                // Thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc v√† ·∫£nh n·ªÅn
                piece.style.width = PIECE_SIZE + 'px';
                piece.style.height = PIECE_SIZE + 'px';
                piece.style.backgroundImage = `url(${IMAGE_SRC})`;
                piece.style.backgroundSize = `${BOARD_SIZE}px ${BOARD_SIZE}px`;
                piece.style.backgroundPosition = `-${c * PIECE_SIZE}px -${r * PIECE_SIZE}px`;

                pieces.push(piece);
            }
        }
        
        shuffleAndPlacePieces(pieces);
    }

    // 2. X√ÅO TR·ªòN V√Ä ƒê·∫∂T M·∫¢NH GH√âP NG·∫™U NHI√äN
    function shuffleAndPlacePieces(arr) {
        // X√°o tr·ªôn m·∫£ng (Fisher-Yates)
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        
        // ƒê·∫∑t m·∫£nh gh√©p v√†o v·ªã tr√≠ ng·∫´u nhi√™n tr√™n board (ban ƒë·∫ßu)
        arr.forEach((piece, index) => {
            const r = Math.floor(Math.random() * ROWS); // V·ªã tr√≠ h√†ng ng·∫´u nhi√™n
            const c = Math.floor(Math.random() * COLS); // V·ªã tr√≠ c·ªôt ng·∫´u nhi√™n

            piece.style.top = r * PIECE_SIZE + 'px';
            piece.style.left = c * PIECE_SIZE + 'px';

            puzzleBoard.appendChild(piece);
        });

        // Sau khi x√°o tr·ªôn, cho ph√©p ki·ªÉm tra
        checkBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        checkBtn.disabled = false;
    }

    // 3. X·ª¨ L√ù K√âO TH·∫¢ (Drag and Drop)
    
    // G√°n s·ª± ki·ªán cho t·ª´ng m·∫£nh gh√©p
    pieces.forEach(piece => {
        piece.addEventListener('mousedown', startDrag);
        piece.addEventListener('touchstart', startDrag); 
    });

    function startDrag(e) {
        if (isGameComplete) return;

        // X·ª≠ l√Ω s·ª± ki·ªán ch·∫°m (touch event)
        const event = e.touches ? e.touches[0] : e;
        dragElement = this;
        dragElement.classList.add('dragging');
        
        // T√≠nh to√°n v·ªã tr√≠ offset ƒë·ªÉ m·∫£nh gh√©p kh√¥ng b·ªã nh·∫£y
        const rect = dragElement.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;

        function moveDrag(e) {
            if (!dragElement) return;
            const event = e.touches ? e.touches[0] : e;

            // T√≠nh to√°n v·ªã tr√≠ m·ªõi
            let newX = event.clientX - offsetX;
            let newY = event.clientY - offsetY;

            // Gi·ªõi h·∫°n trong board
            const boardRect = puzzleBoard.getBoundingClientRect();
            newX = Math.max(boardRect.left, newX);
            newX = Math.min(boardRect.right - PIECE_SIZE, newX);
            
            newY = Math.max(boardRect.top, newY);
            newY = Math.min(boardRect.bottom - PIECE_SIZE, newY);
            
            // C·∫≠p nh·∫≠t v·ªã tr√≠ c·ªßa m·∫£nh gh√©p (relative to the board's parent)
            dragElement.style.left = (newX - boardRect.left) + 'px';
            dragElement.style.top = (newY - boardRect.top) + 'px';
        }

        function endDrag(e) {
            if (!dragElement) return;
            
            // X·ª≠ l√Ω logic snap-to-grid v√† ki·ªÉm tra
            snapToGrid(dragElement);
            
            dragElement.classList.remove('dragging');
            dragElement = null;
            
            document.removeEventListener('mousemove', moveDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', moveDrag);
            document.removeEventListener('touchend', endDrag);
        }

        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveDrag);
        document.addEventListener('touchend', endDrag);
        
        e.preventDefault(); // NgƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh
    }

    // 4. LOGIC SNAP-TO-GRID V√Ä KI·ªÇM TRA ƒê√öNG V·ªä TR√ç
    function snapToGrid(piece) {
        const currentX = parseFloat(piece.style.left);
        const currentY = parseFloat(piece.style.top);

        // T√≠nh to√°n v·ªã tr√≠ c·ªôt v√† h√†ng g·∫ßn nh·∫•t
        let targetCol = Math.round(currentX / PIECE_SIZE);
        let targetRow = Math.round(currentY / PIECE_SIZE);

        // Gi·ªõi h·∫°n l·∫°i trong ph·∫°m vi (0 -> 2)
        targetCol = Math.min(Math.max(0, targetCol), COLS - 1);
        targetRow = Math.min(Math.max(0, targetRow), ROWS - 1);

        // ƒê·∫∑t m·∫£nh gh√©p v√†o v·ªã tr√≠ l∆∞·ªõi
        piece.style.left = targetCol * PIECE_SIZE + 'px';
        piece.style.top = targetRow * PIECE_SIZE + 'px';

        // G√°n v·ªã tr√≠ hi·ªán t·∫°i
        piece.dataset.currentRow = targetRow;
        piece.dataset.currentCol = targetCol;

        checkCorrectness(piece);
    }
    
    // Ki·ªÉm tra xem m·∫£nh gh√©p c√≥ ƒëang ·ªü v·ªã tr√≠ ƒë√∫ng (h√†ng v√† c·ªôt) hay kh√¥ng
    function checkCorrectness(piece) {
        const isCorrect = 
            piece.dataset.correctRow === piece.dataset.currentRow &&
            piece.dataset.correctCol === piece.dataset.currentCol;
        
        piece.classList.toggle('correct', isCorrect);
        return isCorrect;
    }

    // 5. KI·ªÇM TRA TO√ÄN B·ªò V√Ä CHUY·ªÇN H∆Ø·ªöNG
    checkBtn.addEventListener('click', () => {
        if (isGameComplete) return;

        let allCorrect = true;
        
        // Ki·ªÉm tra xem c√≥ 2 m·∫£nh n√†o tr√πng v·ªã tr√≠ kh√¥ng (logic n√¢ng cao)
        // Hi·ªán t·∫°i ch·ªâ ki·ªÉm tra ƒë√∫ng v·ªã tr√≠ target

        pieces.forEach(piece => {
            if (!checkCorrectness(piece)) {
                allCorrect = false;
            }
        });

        if (allCorrect) {
            messageEl.textContent = 'Tuy·ªát v·ªùi! B·∫°n ƒë√£ ho√†n th√†nh b·ª©c tranh! üéâ';
            isGameComplete = true;
            
            // C√†i ƒë·∫∑t chuy·ªÉn h∆∞·ªõng
            setTimeout(() => {
                window.location.href = TARGET_URL; 
            }, 2000); // Chuy·ªÉn h∆∞·ªõng sau 2 gi√¢y
            
            checkBtn.disabled = true;
            checkBtn.textContent = 'ƒêang chuy·ªÉn h∆∞·ªõng...';
            checkBtn.classList.add('bg-green-600');
        } else {
            messageEl.textContent = 'Ch∆∞a ƒë√∫ng, h√£y th·ª≠ s·∫Øp x·∫øp l·∫°i nh√©.';
            checkBtn.classList.add('bg-red-500');
            setTimeout(() => {
                messageEl.textContent = '';
                checkBtn.classList.remove('bg-red-500');
            }, 1500);
        }
    });

    // B·∫Øt ƒë·∫ßu tr√≤ ch∆°i
    createPieces();
</script>